<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo博客搭建过程【修改版】</title>
    <url>/2023/06/30/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="一、快速开始"><a href="#一、快速开始" class="headerlink" title="一、快速开始"></a>一、快速开始</h2><h3 id="Install-environment"><a href="#Install-environment" class="headerlink" title="Install environment"></a>Install environment</h3><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">node.<span class="hljs-keyword">js </span>git <br></code></pre></td></tr></table></figure>

<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Article&quot;</span><br>$ hexo clean <br>$ hexo generate<br>$ hexo s<br></code></pre></td></tr></table></figure>

<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<h3 id="Deploy-to-remote-sites-【github】"><a href="#Deploy-to-remote-sites-【github】" class="headerlink" title="Deploy to remote sites 【github】"></a>Deploy to remote sites 【github】</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># blog目录下安装git部署插件</span><br>$ cnpm install --save hexo-deployer-git<br><span class="hljs-comment"># 配置_config.yml中的deploy属性（github中先创建仓库）</span><br>$ vim _config.yml<br><span class="hljs-comment"># The changes are as follows</span><br>deploy:<br>  <span class="hljs-built_in">type</span>: git<br>  repo: https://github.com/Fancynot04/Fancynot04.github.io.git<br>  branch: master<br><span class="hljs-comment"># 配置账号</span><br>$ git config –global user.name yourname<br>$ git config –global user.email yourname@mail.com<br><span class="hljs-comment"># 生成ssh登录秘钥</span><br>$ ssh-keygen -t rsa -C [yourname@mail.com]<br><span class="hljs-comment"># 把生成的id_rsa.pub文件中内容复制到github上对应仓库的公共key中</span><br><span class="hljs-comment"># 部署到远端</span><br>$ hexo deploy<br></code></pre></td></tr></table></figure>

<h3 id="Enable-additional-ports"><a href="#Enable-additional-ports" class="headerlink" title="Enable additional ports"></a>Enable additional ports</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo p [port]<br></code></pre></td></tr></table></figure>



<h2 id="二、复杂配置"><a href="#二、复杂配置" class="headerlink" title="二、复杂配置"></a>二、复杂配置</h2><ol>
<li><p>图片插入问题</p>
<h2 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h2><p>GitHub 一直拥有各种奇怪的用途，被发掘出来当图床也见怪不怪了。</p>
<ul>
<li>速度：国内可以接受，海外速度很快</li>
<li>CDN：Fastly CDN，几个节点在国内都解禁了的</li>
<li>HTTPS：支持（似乎不支持 HTTP2）</li>
<li>域名：<code>user-images.githubusercontent.com</code></li>
</ul>
<p>上传方式是新建一个 Repo，然后在 Issue 中传图（直接将图片拖动到 issue 输入框即可），GitHub 会将你的图片分发到 GitHub 用的 CDN 中。</p>
<p>这和使用 GitHub Raw 需要 GitHub 的服务器动态生成文件不同，user-image 这个子域名是 GitHub 专门为静态文件准备的，不会让当年某某抢票助手 CC GitHub 的事情重现的。<br>当然，这个接口不是公开的。善待 GitHub。</p>
<p><em>有道云笔记和微博</em></p>
</li>
<li><p>文章的浏览量</p>
</li>
<li><p>评论系统</p>
</li>
<li><p>logo制作</p>
</li>
</ol>
<h2 id="三、问题汇总"><a href="#三、问题汇总" class="headerlink" title="三、问题汇总"></a>三、问题汇总</h2><h3 id="Unable-to-access-‘http…’"><a href="#Unable-to-access-‘http…’" class="headerlink" title="Unable to access ‘http…’"></a>Unable to access ‘http…’</h3><p>原因： git在拉取或提交项目时，中间会有git的http和https代理，但本地环境本身就有SSL协议，所以取消掉git本身的http、https代理，使用本机的代理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ git config --global --<span class="hljs-built_in">unset</span> http.proxy<br>$ git config --global --<span class="hljs-built_in">unset</span> https.proxy<br></code></pre></td></tr></table></figure>



<h3 id="本文链接的url修改"><a href="#本文链接的url修改" class="headerlink" title="本文链接的url修改"></a>本文链接的url修改</h3><p>其中中文部分会用%多少来代替，没有转义，需要改成全英文</p>
]]></content>
  </entry>
  <entry>
    <title>Leecode刷题笔记</title>
    <url>/2023/06/30/Leecode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>按照leecode网站上的做题顺序做到第五题时，发现目前的算法理论基础太差了，对解析中的动态规划思想、边界条件判断都存在不理解的情况，所以本文目前暂时停止更新!在学习完《图解算法数据结构》后随缘更新。。。</p>
</blockquote>
<p>常见数据结构：可分为线性和非线性数据结构，具体如下，</p>
<p><em>数组、链表、栈、队列、树、图、散列表、堆</em></p>
<h3 id="amount：14"><a href="#amount：14" class="headerlink" title="amount：14"></a>amount：14</h3><h3 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C++数据类型"></a>C++数据类型</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++">unordered_map&lt;Node*,Node*&gt; map;<br>vector&lt;<span class="hljs-type">int</span>&gt; nums;<br>deque&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 双端队列：push_back(front)\pop_back(front)\empty\front\back</span><br>stack&lt;<span class="hljs-type">int</span>&gt; A; <span class="hljs-comment">// 栈：pop\top\push</span><br>queue&lt;<span class="hljs-type">int</span>&gt; que; <span class="hljs-comment">// 队列：pop\push\empty\front\back</span><br></code></pre></td></tr></table></figure>

<h3 id="J67-把字符串转换成整数？？"><a href="#J67-把字符串转换成整数？？" class="headerlink" title="J67.把字符串转换成整数？？"></a>J67.把字符串转换成整数？？</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">strToInt</span><span class="hljs-params">(string str)</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            1. 舍去前面的空格</span><br><span class="hljs-comment">            2. 判断第一个是数字或—+，否则无需转换，return 0</span><br><span class="hljs-comment">            3. 连接后续连续或有空格的数字，遇到字母停止</span><br><span class="hljs-comment">            4. 判断数组是否超过范围</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>, bndry = INT_MAX / <span class="hljs-number">10</span>;<br>        <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, sign = <span class="hljs-number">1</span>, length = str.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">if</span>(length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(str[i] == <span class="hljs-string">&#x27; &#x27;</span>)<br>            <span class="hljs-keyword">if</span>(++i == length) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">&#x27;-&#x27;</span>) sign = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">if</span>(str[i] == <span class="hljs-string">&#x27;-&#x27;</span> || str[i] == <span class="hljs-string">&#x27;+&#x27;</span>) i++;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i; j &lt; length; j++) &#123;<br>            <span class="hljs-keyword">if</span>(str[j] &lt; <span class="hljs-string">&#x27;0&#x27;</span> || str[j] &gt; <span class="hljs-string">&#x27;9&#x27;</span>) <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">if</span>(res &gt; bndry || res == bndry &amp;&amp; str[j] &gt; <span class="hljs-string">&#x27;7&#x27;</span>)<br>                <span class="hljs-keyword">return</span> sign == <span class="hljs-number">1</span> ? INT_MAX : INT_MIN;<br>            res = res * <span class="hljs-number">10</span> + (str[j] - <span class="hljs-string">&#x27;0&#x27;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sign * res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="J59-Ⅱ-队列的最大值"><a href="#J59-Ⅱ-队列的最大值" class="headerlink" title="J59. Ⅱ 队列的最大值"></a>J59. Ⅱ 队列的最大值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MaxQueue</span> &#123;<br>    queue&lt;<span class="hljs-type">int</span>&gt; que;<br>    deque&lt;<span class="hljs-type">int</span>&gt; deq;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MaxQueue</span>() &#123; &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">max_value</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> deq.<span class="hljs-built_in">empty</span>() ? <span class="hljs-number">-1</span> : deq.<span class="hljs-built_in">front</span>();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push_back</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>        que.<span class="hljs-built_in">push</span>(value);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            当双端队列不为空，持续删除尾部所有小于value的元素，再插入value，维持deq中为递减状态</span><br><span class="hljs-comment">            这样删除同时也不会使que中最大元素不在其中，删除的只是不会成为最大元素的元素，</span><br><span class="hljs-comment">            即&lt;front和value</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">while</span>(!deq.<span class="hljs-built_in">empty</span>() &amp;&amp; deq.<span class="hljs-built_in">back</span>() &lt; value)<br>            deq.<span class="hljs-built_in">pop_back</span>();<br>        deq.<span class="hljs-built_in">push_back</span>(value);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pop_front</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(que.<span class="hljs-built_in">empty</span>()) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> val = que.<span class="hljs-built_in">front</span>();<br>        <span class="hljs-comment">// 仅当队列中删除的值与维护非严格递减的双端队列deq的front相同时，deq才弹出front元素</span><br>        <span class="hljs-keyword">if</span>(val == deq.<span class="hljs-built_in">front</span>())<br>            deq.<span class="hljs-built_in">pop_front</span>();<br>        que.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">return</span> val;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MaxQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MaxQueue* obj = new MaxQueue();</span><br><span class="hljs-comment"> * int param_1 = obj-&gt;max_value();</span><br><span class="hljs-comment"> * obj-&gt;push_back(value);</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;pop_front();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>



<h3 id="J59-Ⅰ滑动窗口的最大值"><a href="#J59-Ⅰ滑动窗口的最大值" class="headerlink" title="J59 .Ⅰ滑动窗口的最大值"></a>J59 .Ⅰ滑动窗口的最大值</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment">	单调队列（双端队列）</span><br><span class="hljs-comment">	pop移除的元素value等于单调队列等于出口元素则弹出，否则不操作</span><br><span class="hljs-comment">	push，插入的元素value大于出口元素则弹出</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyQueue</span> &#123; <span class="hljs-comment">//单调队列（从大到小）</span><br>    <span class="hljs-keyword">public</span>:<br>        deque&lt;<span class="hljs-type">int</span>&gt; que; <span class="hljs-comment">// 使用deque来实现单调队列</span><br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value == que.<span class="hljs-built_in">front</span>()) &#123;<br>                que.<span class="hljs-built_in">pop_front</span>();<br>            &#125;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (!que.<span class="hljs-built_in">empty</span>() &amp;&amp; value &gt; que.<span class="hljs-built_in">back</span>()) &#123;<br>                que.<span class="hljs-built_in">pop_back</span>();<br>            &#125;<br>            que.<span class="hljs-built_in">push_back</span>(value);<br><br>        &#125;<br>        <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">front</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> que.<span class="hljs-built_in">front</span>();<br>        &#125;<br>    &#125;;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">maxSlidingWindow</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        MyQueue que;<br>        vector&lt;<span class="hljs-type">int</span>&gt; result;<br>        <span class="hljs-keyword">if</span> (nums.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123; <span class="hljs-comment">// 先将前k的元素放进队列</span><br>            que.<span class="hljs-built_in">push</span>(nums[i]);<br>        &#125;<br>        result.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()); <span class="hljs-comment">// result 记录前k的元素的最大值</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &lt; nums.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            que.<span class="hljs-built_in">pop</span>(nums[i - k]); <span class="hljs-comment">// 模拟滑动窗口的移动</span><br>            que.<span class="hljs-built_in">push</span>(nums[i]); <span class="hljs-comment">// 模拟滑动窗口的移动</span><br>            result.<span class="hljs-built_in">push_back</span>(que.<span class="hljs-built_in">front</span>()); <span class="hljs-comment">// 记录对应的最大值</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;;<br><br><br></code></pre></td></tr></table></figure>



<h3 id="J58-左旋转字符串"><a href="#J58-左旋转字符串" class="headerlink" title="J58 .左旋转字符串"></a>J58 .左旋转字符串</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        字符串切片: </span><br><span class="hljs-comment">            切片函数都是前闭后开</span><br><span class="hljs-comment">            return s.substr(n, s.size()) + s.substr(0, n);</span><br><span class="hljs-comment">        列表遍历拼接: </span><br><span class="hljs-comment">        三次翻转 C++字符串是可变类型，可用离散数学方式</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span>:	<br>        <span class="hljs-function">string <span class="hljs-title">reverseLeftWords</span><span class="hljs-params">(string s, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>            <span class="hljs-built_in">reverseString</span>(s, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">reverseString</span>(s, n, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">reverseString</span>(s, <span class="hljs-number">0</span>, s.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>    <span class="hljs-keyword">private</span>:<br>        <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverseString</span><span class="hljs-params">(string&amp; s, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>            <span class="hljs-keyword">while</span>(i &lt; j) <span class="hljs-built_in">swap</span>(s[i++], s[j--]);<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>





<h3 id="J35-复杂链表的复制"><a href="#J35-复杂链表的复制" class="headerlink" title="J35.复杂链表的复制"></a>J35.复杂链表的复制</h3><figure class="highlight c++"><table><tr><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        Node* cur = head;<br>        unordered_map&lt;Node*, Node*&gt; map;<br>        <span class="hljs-comment">// 3. 复制各节点，并建立 “原节点 -&gt; 新节点” 的 Map 映射</span><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            map[cur] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val);<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur = head;<br>        <span class="hljs-comment">// 4. 构建新链表的 next 和 random 指向</span><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>) &#123;<br>            map[cur]-&gt;next = map[cur-&gt;next];<br>            map[cur]-&gt;random = map[cur-&gt;random];<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-comment">// 5. 返回新链表的头节点</span><br>        <span class="hljs-keyword">return</span> map[head];<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">	方法二 【拼接+拆分】</span><br><span class="hljs-comment">	1. 创建新node插入原链表的每个相同元素后面</span><br><span class="hljs-comment">		Node* tmp = new Node(cur-&gt;val);</span><br><span class="hljs-comment">	2. 通过链接链表，使其达到第一个方法：map的效果。</span><br><span class="hljs-comment">		cur-&gt;next-&gt;random = cur-&gt;random-&gt;next;</span><br><span class="hljs-comment">	3. 拆分旧新链表</span><br><span class="hljs-comment">		pre-&gt;next = pre-&gt;next-&gt;next;</span><br><span class="hljs-comment">         cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>







<h3 id="J06-从尾到头打印链表"><a href="#J06-从尾到头打印链表" class="headerlink" title="J06.从尾到头打印链表"></a>J06.从尾到头打印链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode(int x) &#123; val = x; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    ArrayList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Integer&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        终止条件：head==none时，越过链表结尾，返回[]</span><br><span class="hljs-comment">        递归过程：访问下一个结点head.next</span><br><span class="hljs-comment">        回溯阶段: 将当前值head.val加入tmp</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] reversePrint(ListNode head) &#123;<br>        recur(head);<br>        <span class="hljs-type">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[tmp.size()];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;arr.length;i++)&#123;<br>            arr[i] = tmp.get(i);   <br>        &#125;<br>        <span class="hljs-keyword">return</span> arr;<br>        <span class="hljs-comment">// 使用栈来倒序输出，使用addLast进栈，removeList出栈</span><br>        <span class="hljs-comment">//    LinkedList&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();</span><br>        <span class="hljs-comment">//    while(head != null) &#123;</span><br>        <span class="hljs-comment">//        stack.addLast(head.val);</span><br>        <span class="hljs-comment">//        head = head.next;</span><br>        <span class="hljs-comment">//    &#125;</span><br>        <span class="hljs-comment">//    int[] res = new int[stack.size()];</span><br>        <br>    &#125;<br>    <span class="hljs-comment">// 递归中调用自身，终止条件返回到上一个函数的下一句执行。</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">recur</span><span class="hljs-params">(ListNode head)</span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        recur(head.next);<br>        tmp.add(head.val);<br>    &#125;<br>   <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="J24-反转链表"><a href="#J24-反转链表" class="headerlink" title="J24.反转链表"></a>J24.反转链表</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">        利用list逆转再传入值。。。</span><br><span class="hljs-comment">        逆转是整个node移动，不只是值！！</span><br><span class="hljs-comment">    */</span><br>LinkedList&lt;Integer&gt; tmp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>    <span class="hljs-keyword">while</span>(p!=<span class="hljs-literal">null</span>)&#123;<br>        tmp.add(p.val);<br>        p = p.next;<br>    &#125;<br>    p = head;<br>    <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>)&#123;<br>        p.val = tmp.removeLast();<br>        p = p.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        迭代-双指针，逆转节点间指针方向</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-comment">// pre、cur、tmp</span><br>     ListNode cur= head, pre=<span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span>(cur !=<span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> cur.next; <span class="hljs-comment">//暂存cur后继节点</span><br>        cur.next = pre; <span class="hljs-comment">//逆转节点间方向</span><br>        pre = cur; <span class="hljs-comment">//pre后移</span><br>        cur = tmp; <span class="hljs-comment">// cur后移</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> pre; <span class="hljs-comment">// 跳出循环时，cur为空，pre指向之前的cur，即为逆转后的头节点</span><br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="J09-用两个栈实现队列"><a href="#J09-用两个栈实现队列" class="headerlink" title="J09.用两个栈实现队列"></a>J09.用两个栈实现队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CQueue</span> &#123;<br>    LinkedList&lt;Integer&gt; A,B;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CQueue</span><span class="hljs-params">()</span> &#123;<br>        A = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>        B = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;Integer&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">appendTail</span><span class="hljs-params">(<span class="hljs-type">int</span> value)</span> &#123;<br>       A.addLast(value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">deleteHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            队列特性为先进先出，所以当存入栈中时元素在最底部，不好删除。</span><br><span class="hljs-comment">            solution：栈A放入元素，栈B逆转栈A元素，栈B的顶部就是要删除的元素。</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(!B.isEmpty())&#123;<br>            <span class="hljs-keyword">return</span> B.removeLast();<br>        &#125;<br>        <span class="hljs-comment">// 接下来就是B为空的情况</span><br>        <span class="hljs-keyword">if</span>(A.isEmpty()) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(!A.isEmpty())&#123;<br>            B.addLast(A.removeLast());<br>        &#125;<br>        <span class="hljs-keyword">return</span> B.removeLast();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your CQueue object will be instantiated and called as such:</span><br><span class="hljs-comment"> * CQueue obj = new CQueue();</span><br><span class="hljs-comment"> * obj.appendTail(value);</span><br><span class="hljs-comment"> * int param_2 = obj.deleteHead();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<h3 id="J30-包含min元素的栈"><a href="#J30-包含min元素的栈" class="headerlink" title="J30.包含min元素的栈"></a>J30.包含min元素的栈</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinStack</span> &#123;<br>    <span class="hljs-keyword">public</span>:<br>        <span class="hljs-comment">/** </span><br><span class="hljs-comment">            initialize your data structure here. </span><br><span class="hljs-comment">            创建两个栈：A用来push、pop、top函数；B用来实现min函数</span><br><span class="hljs-comment">        */</span><br>        stack&lt;<span class="hljs-type">int</span>&gt; A, B;<br>        MinStack() &#123;<br><br>        &#125;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>            <br>            A.push(x);<br>            <span class="hljs-comment">// 为了保证B中的非严格递减序列，在B为空或&lt;=top时push到B中，</span><br>            <span class="hljs-comment">// 使B的栈顶始终是当前A中最小的元素</span><br>            <span class="hljs-keyword">if</span>(B.empty() || B.top() &gt;= x)<br>                B.push(x);<br>        &#125;<br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 仅当A中pop的是最小值时，才删除B中栈顶元素</span><br>            <span class="hljs-keyword">if</span>(A.top() == B.top())<br>                B.pop();<br>            A.pop();<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-title function_">top</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> A.top();<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-title function_">min</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> B.top();<br>        &#125;<br>&#125;;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Your MinStack object will be instantiated and called as such:</span><br><span class="hljs-comment"> * MinStack* obj = new MinStack();</span><br><span class="hljs-comment"> * obj-&gt;push(x);</span><br><span class="hljs-comment"> * obj-&gt;pop();</span><br><span class="hljs-comment"> * int param_3 = obj-&gt;top();</span><br><span class="hljs-comment"> * int param_4 = obj-&gt;min();</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 列表反转</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reverseList</span><span class="hljs-params">(<span class="hljs-type">int</span>[] list)</span>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> list.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len/<span class="hljs-number">2</span>;i++)&#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> list[i];<br>        list[i] = list[len-i-<span class="hljs-number">1</span>];<br>        list[len-i-<span class="hljs-number">1</span>] = temp;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[] twoSum(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> target) &#123;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> nums.length;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(target-nums[i]))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[] &#123;map.get(target-nums[i]),i&#125;;<br>            map.put(nums[i],i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;<span class="hljs-number">0</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            两个链表从末尾开始相加，需要考虑进位（内部、最高位）、相加结束条件 </span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">prev</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 存放相加结果,此为头节点，不存值！</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> prev; <span class="hljs-comment">// 指针移动</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">carry</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-comment">// 进位</span><br>        <span class="hljs-keyword">while</span>(l1!=<span class="hljs-literal">null</span> || l2!=<span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-comment">//链表当前位数值取决于是否移动指针为空，空则代表两加数位数不同，高位不够的取0</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> l1 != <span class="hljs-literal">null</span> ? l1.val:<span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> l2 != <span class="hljs-literal">null</span> ? l2.val:<span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> (x+y+carry)%<span class="hljs-number">10</span>; <span class="hljs-comment">//如果结果大于10则只取个位数</span><br>            <span class="hljs-comment">//是否有进位</span><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">            if((x+y+carry)/10 != 0) </span><br><span class="hljs-comment">                carry=1;</span><br><span class="hljs-comment">            else </span><br><span class="hljs-comment">                carry=0;</span><br><span class="hljs-comment">             */</span><br>             carry = (x+y+carry)/<span class="hljs-number">10</span>!=<span class="hljs-number">0</span> ? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 仅当指针不为空时才后移</span><br>            <span class="hljs-keyword">if</span>(l1!=<span class="hljs-literal">null</span>) l1= l1.next;<br>            <span class="hljs-keyword">if</span>(l2!=<span class="hljs-literal">null</span>) l2= l2.next;<br>            <span class="hljs-comment">// 创建结点同时与cur连接？！</span><br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(sum);<br>            cur = cur.next;<br>        &#125;<br>        <span class="hljs-comment">//处理最高位进位</span><br>        <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>)&#123;<br>            cur.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(carry);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> prev.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-无重复字符的最大子串"><a href="#3-无重复字符的最大子串" class="headerlink" title="3.无重复字符的最大子串"></a>3.无重复字符的最大子串</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">            滑动窗口</span><br><span class="hljs-comment">            使用数据结构为集合，查删速度高于list，通过哈希计算获得</span><br><span class="hljs-comment">            hashmap：散列表，根据键的hashcode存储数据，键唯一，时间复杂度O(1)</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">//特殊情况len=0直接返回</span><br>        <span class="hljs-keyword">if</span>(s.length()==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;Character,Integer&gt;();<br>        <span class="hljs-type">int</span> left=<span class="hljs-number">0</span>; <span class="hljs-comment">//滑动窗口左指针</span><br>        <span class="hljs-type">int</span> maxLen=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length();i++)&#123;<br>            <span class="hljs-keyword">if</span>(map.containsKey(s.charAt(i)))&#123;<br>                <span class="hljs-comment">/*</span><br><span class="hljs-comment">                    当前map中没有重复子母时，left不动；</span><br><span class="hljs-comment">                    当前map有重复字母，left需定位到重复字母后一位；</span><br><span class="hljs-comment">                    但由于后面的更新策略只会更新当前重复字母，前面的没有删除，如abba检测a时之前的a还在。</span><br><span class="hljs-comment">                    所以会存在map不一定表示最小字串，</span><br><span class="hljs-comment">                */</span><br>                left =Math.max(left, map.get(s.charAt(i))+<span class="hljs-number">1</span>); <br>            &#125;<br>            <span class="hljs-comment">//不论重复与否，都会更新s.charAt(i)的位置，但只更新单个字母。</span><br>            map.put(s.charAt(i),i);<br>            <span class="hljs-comment">// 当前滑动窗口可能变小，取历史记录中最大的值</span><br>            maxLen = Math.max(maxLen, i-left+<span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> maxLen;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">        	方法一：暴力解法，合并成一个数组，计算得到中位数</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> nums2.length;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>&amp;&amp;n==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(m==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(n%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                pivot = (nums2[n/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>]+nums2[n/<span class="hljs-number">2</span>])/<span class="hljs-number">2.0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                pivot = nums2[n/<span class="hljs-number">2</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> pivot;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(m%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>                pivot = (nums1[m/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>]+nums1[m/<span class="hljs-number">2</span>])/<span class="hljs-number">2.0</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                pivot = nums1[m/<span class="hljs-number">2</span>];<br>            &#125;<br>            <span class="hljs-keyword">return</span> pivot;<br>        &#125;<br>        <span class="hljs-type">int</span>[] sumArr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n+m];<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> k=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i&lt;m&amp;&amp;j&lt;n)&#123;<br>            <span class="hljs-keyword">if</span>(nums1[i]&lt;=nums2[j])&#123;<br>                sumArr[k++]=nums1[i++];<br>            &#125;<br>            <span class="hljs-keyword">else</span>&#123;<br>                sumArr[k++]=nums2[j++];<br>            &#125;<br><br>        &#125;<br>        <span class="hljs-keyword">while</span>(i&lt;m) sumArr[k++] = nums1[i++];<br>        <span class="hljs-keyword">while</span>(j&lt;n) sumArr[k++] = nums2[j++];<br><br>        <span class="hljs-keyword">if</span>((n+m)%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>            pivot = (sumArr[(n+m)/<span class="hljs-number">2</span>-<span class="hljs-number">1</span>]+sumArr[(n+m)/<span class="hljs-number">2</span>])/<span class="hljs-number">2.0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            pivot = sumArr[(n+m)/<span class="hljs-number">2</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> pivot;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> m + n;<br>        <span class="hljs-keyword">if</span> (len % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> len / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> getKthElement(nums1, nums2, mid + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid1</span> <span class="hljs-operator">=</span> len / <span class="hljs-number">2</span> - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid2</span> <span class="hljs-operator">=</span> len / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">return</span> (getKthElement(nums1, nums2, mid1 + <span class="hljs-number">1</span>) + getKthElement(nums1, nums2, mid2 + <span class="hljs-number">1</span>)) / <span class="hljs-number">2.0</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/* 主要思路：要找到第 k (k&gt;1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较</span><br><span class="hljs-comment">     * 这里的 &quot;/&quot; 表示整除</span><br><span class="hljs-comment">     * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个</span><br><span class="hljs-comment">     * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个</span><br><span class="hljs-comment">     * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) &lt;= k-2 个</span><br><span class="hljs-comment">     * 这样 pivot 本身最大也只能是第 k-1 小的元素</span><br><span class="hljs-comment">     * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums1 数组</span><br><span class="hljs-comment">     * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 &quot;删除&quot;，剩下的作为新的 nums2 数组</span><br><span class="hljs-comment">     * 由于 &quot;删除&quot; 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getKthElement</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums1, <span class="hljs-type">int</span>[] nums2, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> nums1.length, n = nums2.length;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 边界情况</span><br>            <span class="hljs-keyword">if</span> (i == m) &#123;<br>                <span class="hljs-keyword">return</span> nums2[j + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (j == n) &#123;<br>                <span class="hljs-keyword">return</span> nums1[i + k - <span class="hljs-number">1</span>];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (k == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> Math.min(nums1[i], nums2[j]);<br>            &#125;<br>            <span class="hljs-comment">// 正常情况</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">half</span> <span class="hljs-operator">=</span> k / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newi</span> <span class="hljs-operator">=</span> Math.min(i + half, m) - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">newj</span> <span class="hljs-operator">=</span> Math.min(j + half, n) - <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivot1</span> <span class="hljs-operator">=</span> nums1[newi];<br>            <span class="hljs-type">int</span> <span class="hljs-variable">pivot2</span> <span class="hljs-operator">=</span> nums2[newj];<br>            <span class="hljs-keyword">if</span> (pivot1 &lt;= pivot2) &#123;<br>                <span class="hljs-comment">// 更新 k</span><br>                k -= newi - i + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 舍弃 nums1 部分元素</span><br>                i = newi + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 更新 k</span><br>                k -= newj - j + <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 舍弃 nums2 部分元素</span><br>                j = newj + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="6-最长回文子串"><a href="#6-最长回文子串" class="headerlink" title="6.最长回文子串"></a>6.最长回文子串</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">longestPalindrome</span><span class="hljs-params">(String s)</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 暴力解法：遍历数组两遍，每次检查是否是回文串。</span><br><span class="hljs-comment">         * O(n^3); O(1)</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> s.length();<br>         <span class="hljs-keyword">if</span>(len&lt;<span class="hljs-number">2</span>)&#123;<br>             <span class="hljs-keyword">return</span> s;<br>         &#125;<br>         <span class="hljs-comment">//截取字符串会有一定的性能消耗，等价方式如下</span><br>         <span class="hljs-type">int</span> <span class="hljs-variable">maxLen</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>         <span class="hljs-type">int</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>         <span class="hljs-type">char</span>[] charArray = s.toCharArray();<br>        <span class="hljs-comment">//枚举所有长度大于等于2的字串</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;len-<span class="hljs-number">1</span>;i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=i+<span class="hljs-number">1</span>;j&lt;len;j++)&#123;<br>                <span class="hljs-comment">// 只对长度超过当前最大回文串进行判断</span><br>                <span class="hljs-keyword">if</span>(j-i+<span class="hljs-number">1</span>&gt;maxLen &amp;&amp; validPalindromic(charArray,i,j))&#123;<br>                    maxLen = j-i+<span class="hljs-number">1</span>;<br>                    begin = i;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s.substring(begin, begin +maxLen);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">        验证子串[left..right]是否为回文串    </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validPalindromic</span><span class="hljs-params">(<span class="hljs-type">char</span>[] charArray, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right)</span>&#123;<br>        <span class="hljs-keyword">while</span>(left&lt;right)&#123;<br>            <span class="hljs-keyword">if</span>(charArray[left]!=charArray[right])&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>            left++;<br>            right--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>算法</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Life Advice</title>
    <url>/2023/07/07/Life-Advice/</url>
    <content><![CDATA[<h2 id="1-来自某评论的建议"><a href="#1-来自某评论的建议" class="headerlink" title="1.来自某评论的建议"></a>1.来自某评论的建议</h2><p>渡有心人，送给年轻人！人生最有价值的知识主次及比例<br>①预防人生意外事故、研究透彻各种不良习气危害并避之，学会休息，预防运动损伤，健体使身体稳固不易损伤的知识（60％）；<br>②上好学，培养傍身技能，记住稀缺是精髓，社会正常运行必要的职业，生活刚需手艺活，专研透了，也能养你一辈子（30％）；<br>③怎么教育子女，做好社会角色分工（8％）；<br>④艺术素养 乐器、绘画、舞蹈等（2％）。<br>健康活着，持续健康活着，持续幸福健康活着。起步的迟没关系，只要跑的越久，就跑的越远。<br>清醒的头脑，健全的四肢，充实的肠胃，是每天要核查和保持的。<br>保持健康，生活便进可攻，退可守。<br>警惕贪（对于喜好的过于偏执）、嗔（对于讨厌的反应过激）、痴（对不明事理表现贪与嗔的反应），一旦发作，让人失去驾驭人生大局的基本理智。<br>凡事三思:思危、思退、思变。<br>这个社会需要有真实能力的人去做事<br>这个世界健康其实才是最稀缺的东西<br>其他:充分准备，克制墨菲定律。<br>①最好一辈子不沾酒，醉酒、喝酒不爬高，醉了一定要找低矮床铺侧卧休息。<br>②膝关节是人体最复杂的关节，一定不要损伤，因为最复杂，一旦损伤，修复也是最难的。保护膝盖知识。<br>③健身体成习惯，心平静，充分热身，量力而行，场地光线充足安全无障碍。<br>④我们成长中，各种原因原生环境，思想上行为上或多或少都背负着那么一些歪理邪说成分，长大了，要懂得筛查找出，不然它就好比一颗雷，谁知道那天触发了它就炸了。<br>⑤终生要思考追求的话题:这个世界的真实面貌是什么样的，事实是什么；生存能力中判断力高于一切，只有真实客观的判断才能做出正确的选择，什么是好。<br>⑥远离极度自私垃圾人，远离以权力背景压人的人，若不可避免，至少与他们相处时，一定要思危，嗅到不对时，及时跑路，退到安全的地方，以逸待劳，思考应对。<br>⑦身材管理，体重&#x2F;身高平方≤23kg&#x2F;m²<br>推荐叔本华的《人生的智慧》，梁应林《人生意外800鉴》，杨渝平《运动损伤那些事》 ，北泽杏子《讨厌!喝酒好可怕》 预防的疾病病毒肝炎（疫苗）、艾滋病（洁身）、肺结核（健身营养）、膝关节半月板撕裂（软骨损伤不可再生）、椎间盘突出、老人股骨头骨折（老人死亡骨折）尘肺（呼衰），脊髓损伤、脑梗偏瘫（生活不能自理），狂犬病（高死亡率）。出门看天气防雷电溺水、高空坠物、车祸、踩空、滑倒。<br>健康是为了生命充分绽放。<br>早意识到这些，生活中主动避免。<img  src="https://i0.hdslb.com/bfs/emote/bf7e00ecab02171f8461ee8cf439c73db9797748.png@48w_48h.webp"  ><span class="image-caption">[脱单doge]</span></p>
<hr>
<h2 id="2-如何寻找有效的学习资源"><a href="#2-如何寻找有效的学习资源" class="headerlink" title="2.如何寻找有效的学习资源"></a>2.如何寻找有效的学习资源</h2><ol>
<li>按照时间和播放量先做粗选,时间越接近现在的越新,看得人越多越热闹(但不一定最好)</li>
<li>这套教程中<strong>老师会不会经常不加解释地就引入新的概念</strong>，侄于你听着听着就不知道他在讲什么<br>了一如果是, 说明这套教程他不是给你准备的(除非他明确说了这里先怀用搞懂)</li>
<li>这套教程中，<strong>老师是不是在讲更多背后的原理</strong>，而缺乏示范操作一如果是, 说明这套教程不适<br>合新手入门，<strong>一套好的新手教程应该只关注两个事情:这是什么，这怎么用。</strong>如果老师大部分时<br>间都是在努力地解释背后的原理，这会消磨大家的热情，看着看着就会觉得:噢,好像知道了很多，但是好像也没学会什么。</li>
<li>这套教程中，<strong>老师是不是从来不出错，因为他总是预知了哪里会出错</strong>一如果是,说明跟着这个老师学,你会遇到很多自己呒法解决的问题。因为他没有给你示范怎么解决问题。一好的教程，老师明明知道这么操作会出问题，他还是会先这么操作一下， 让大家看到问题,再标范如<br>何解决。这很重要!</li>
</ol>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>考研复习计划</title>
    <url>/2023/07/03/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<h1 id="2024复习指南"><a href="#2024复习指南" class="headerlink" title="2024复习指南"></a>2024复习指南</h1><p>准则： 投入进入，再进行调整</p>
<ol>
<li>每天不低于7小时的学习时间</li>
<li>累了休息半天（下午），两个晚上用来运动</li>
<li>周期性的制定计划，到期检查完成度</li>
<li>制定年度目标</li>
</ol>
<hr>
<h2 id="1-数学"><a href="#1-数学" class="headerlink" title="1.数学"></a>1.数学</h2><hr>
<h2 id="2-408"><a href="#2-408" class="headerlink" title="2.408"></a>2.408</h2><hr>
<h2 id="3-英语"><a href="#3-英语" class="headerlink" title="3.英语"></a>3.英语</h2><hr>
<h2 id="4-政治"><a href="#4-政治" class="headerlink" title="4.政治"></a>4.政治</h2><hr>
<h1 id="2023复习指南"><a href="#2023复习指南" class="headerlink" title="2023复习指南"></a>2023复习指南</h1><p><strong>总分 305 &#x3D;49+69+103+84</strong></p>
<p>调整复习重心：数学down，专业课keep，政治、英语up</p>
<ol>
<li><p>稳住心态，严格作息，持续走动</p>
</li>
<li><p>注重效率、少刷手机、中午&amp;晚上多休息</p>
</li>
<li><p>期中考试和课程作业认真准备</p>
</li>
<li><p>加油，就靠武汉理工大学了，目标分数在370左右：120+110+75+65</p>
</li>
</ol>
<hr>
<h2 id="【数学】"><a href="#【数学】" class="headerlink" title="【数学】"></a>【数学】</h2><p>    从9月份刚开始的18讲完成剩余二重积分和多元函数微积分章节后，再到660的高数部分完成后，以及1000题的线性代数部分的每章的前10道题；以及中间完成了13-17年的数学真题；总用时截止到今天10月22日；</p>
<p>    之后的学习计划：主要内容是真题中的内容，重点关注知识遗漏点、易错点和容易得分或常考的题。</p>
<ol>
<li><p>真题刷到20年，from 10月26日 to 10月31日；留最后两年的真题检查</p>
</li>
<li><p>之后总结试卷中的易错知识点（卷子正面写上123点），按专题再查看一遍；此过程详细到卷子做完之后再具体计划（最长10天，估计可能超过）</p>
</li>
<li><p>背诵一些记忆的考点（重要，everyday）</p>
</li>
</ol>
<hr>
<h2 id="【专业课】"><a href="#【专业课】" class="headerlink" title="【专业课】"></a>【专业课】</h2><p>    专业课的进度一直都算比较慢的，原因就是开始时间太晚了，同时前一个月的学习方法有问题导致后期单日的复习时长都维持在3h以上，目前总复习时间已经超过了数学（番茄钟所记录的）；从暑假前开始到开学后几天完成了408四本书的一轮复习，之后截止到10月22日，已经完成了408的数据结构、计算机组成原理和操作系统的第二轮复习，但ds的第二轮复习是存在问题，之后会根据做题的情况再决定复习方法；</p>
<p>    之后的复习计划：主要内容是计算机网络的第二轮、真题的部分，大概是从09-22年，重点关注常考的知识点，放弃一些偏僻或不常考的内容；</p>
<ol>
<li><p>10月23日-&gt;10月25日，完成计算机网络的第二轮复习（容错26日）</p>
</li>
<li><p>之后开始刷真题评估一下，刷完所有的真题（估计得到11月末）</p>
</li>
<li><p>每次刷完真题后对挑选重要得知识点rethink一下</p>
</li>
</ol>
<hr>
<h2 id="【英语】"><a href="#【英语】" class="headerlink" title="【英语】"></a>【英语】</h2><p>        英语的复习从大三下的单词背诵和语法复习，以及暑假期间划水般的英语一真题把基础复习个大概；然后回校后，开始重新复习单词和写英二的卷子；总的来收，阅读方面还是有一些不足，最终目标大概是最多错两个；</p>
<p>    之后的计划：主要内容是阅读和大小作文（from11月15日。动态调整）</p>
<ol>
<li><p>真题往后做，到2021年（一般都是晚上，白天看会单词）</p>
</li>
<li><p>之后开始分别集中训练完型填空和新题型</p>
</li>
<li><p>查找大小作文有关资料，开始构建作文框架和背诵固定专题</p>
</li>
<li><p>重新刷之前的阅读和22年的卷子</p>
</li>
</ol>
<hr>
<h2 id="【政治】"><a href="#【政治】" class="headerlink" title="【政治】"></a>【政治】</h2><p>    政治的复习是时间最短的，目标分数大概在65-70分之间，之前的主要学习方式看徐涛的课程和做1000题（一开始学习强度较大，所以看视频水时间），后来根据徐涛冲刺笔记刷1000题，截止到10月22日，1000题还是没有刷完，但不算太急</p>
<p>    之后的计划：集中在冲刺笔记的阅读复习背诵理解、以及1000题马原和史纲部分的重写</p>
<ol>
<li><p>每天的背诵笔记内容复习指标，1000题的复习</p>
</li>
<li><p>之后出来肖四肖八后开始背诵卷子（预留一定的时间）</p>
</li>
<li><p>总体原则就是不要花费过多的时间在政治上，但要重视，每天最基本的时间要保持不变</p>
</li>
</ol>
<hr>
<h1 id="最后不到一个月"><a href="#最后不到一个月" class="headerlink" title="最后不到一个月"></a>最后不到一个月</h1><p>数学：</p>
<p>【1】</p>
<ol>
<li><p>微分方程的综合题</p>
</li>
<li><p>多元函数的极值与最值</p>
</li>
<li><p>多元复合函数与隐函数求导</p>
</li>
<li><p>微分方程的物理应用</p>
</li>
<li><p>泰勒公式与应用</p>
</li>
<li><p>微分中值定理</p>
</li>
</ol>
<p>【2】</p>
<ol>
<li>选填技巧课，还有4堂课</li>
</ol>
<p>    线代总共7堂课，听完</p>
<ol>
<li><p>明天中午尝试一下，看看效果</p>
</li>
<li><p>可以的话可以在中午或晚上听</p>
</li>
<li><p>重新看一下1000题上的线代</p>
</li>
</ol>
<p>【3】</p>
<ol>
<li><p>重新复习真题上的错题，此阶段与【1】同时进行</p>
</li>
<li><p>总结做题方法，此阶段同上</p>
</li>
</ol>
<p>专业课：</p>
<ol>
<li>待续</li>
</ol>
]]></content>
  </entry>
</search>
